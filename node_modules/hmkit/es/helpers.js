import { ieee754DoubleToBase10, ieee754ToBase10, pad, uint8toInt8 } from './encoding';

export function bytesSum(bytes) {
  var hex = bytes.map(function (decimal) {
    return pad(decimal.toString(16), 2);
  }).reduce(function (memo, i) {
    return memo + i;
  }, '');
  return Number('0x' + hex);
}

export function uint8Decoder(bytes) {
  return uint8toInt8(bytesSum(bytes));
}

export function chunkArray(array) {
  var chunkCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var sets = [];
  var chunkSize = array.length / chunkCount;
  var i = 0;

  while (i < chunkCount) {
    sets[i] = array.splice(0, chunkSize);
    i++;
  }

  return sets;
}

export function switchDecoder(options) {
  return function (bytes) {
    return bytes.length > 0 && bytes[0] in options ? options[bytes[0]] : null;
  };
}

export function dateDecoder(bytes) {
  if (bytes.length === 5) {
    var date = new Date();

    date.setUTCFullYear(2000 + bytes[0], bytes[1] - 1, bytes[2]);
    date.setUTCHours(bytes[3], bytes[4], 0, 0);

    return date;
  } else if (bytes.length === 8) {
    var utcOffset = bytesSum(bytes.slice(6, 8)) << 16 >> 16;
    var _date = new Date();

    _date.setUTCFullYear(2000 + bytes[0], bytes[1] - 1, bytes[2]);
    _date.setUTCHours(bytes[3], bytes[4] - utcOffset, bytes[5], 0);

    return _date;
  }

  return null;
}

export function coordinatesDecoder(data) {
  return {
    latitude: getRoundedIeee754DoubleToBase10(6)(data.slice(0, data.length / 2)),
    longitude: getRoundedIeee754DoubleToBase10(6)(data.slice(data.length / 2))
  };
}

export function getRoundedIeee754ToBase10(precision) {
  var precisionMultiplier = Math.pow(10, precision);

  return function () {
    var unrounded = ieee754ToBase10.apply(undefined, arguments);
    return Math.round(unrounded * precisionMultiplier) / precisionMultiplier;
  };
}

export function getRoundedIeee754DoubleToBase10(precision) {
  var precisionMultiplier = Math.pow(10, precision);

  return function () {
    var unrounded = ieee754DoubleToBase10.apply(undefined, arguments);
    return Math.round(unrounded * precisionMultiplier) / precisionMultiplier;
  };
}

export function matrixZoneDecoder(bytes) {
  return {
    rows: (bytes[0] & 0xf0) >> 4,
    columns: bytes[0] & 0x0f
  };
}

export function progressDecoder(bytes) {
  return bytes[0] / 100;
}

export function activeInactiveDecoder() {
  return switchDecoder({
    0x00: 'inactive',
    0x01: 'active'
  });
}

export function percentToInteger(value) {
  return value > 0.0 && value < 1.0 ? value * 100 : value;
}

export function isArray(value) {
  return value.BYTES_PER_ELEMENT && Object.prototype.toString.call(value.buffer) === '[object ArrayBuffer]' || Array.isArray(value);
}